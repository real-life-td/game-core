package test

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Code generated by tools/operation-generator.go DO NOT EDIT
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

type testModelInitOperation struct {
	NewInt             *int
	NewIntPointer      *int
	NewIntArray        []int
	AdditionalIntArray []int
	ToRemoveIntArray   []int
}
type testModelOperation struct {
	NewInt             *int
	NewIntPointer      *int
	NewIntArray        []int
	AdditionalIntArray []int
	ToRemoveIntArray   []int
}
type testModelDelta struct {
	int        *int
	intPointer *int
	intArray   []int
}

func (t *testModel) InitOperation(o *testModelInitOperation) {
	if o.NewInt != nil {
		t.int = *o.NewInt
	}
	if o.NewIntPointer != nil {
		t.intPointer = o.NewIntPointer
	}
	if o.NewIntArray != nil {
		t.intArray = o.NewIntArray
	}
	if o.AdditionalIntArray != nil {
		if t.intArray == nil {
			t.intArray = make([]int, 0)
		}
		t.intArray = append(t.intArray, o.AdditionalIntArray...)
	}
	if o.ToRemoveIntArray != nil {
		if t.intArray != nil {
			for _, toRemove := range o.ToRemoveIntArray {
				indexOf := -1
				for i, elm := range t.intArray {
					if elm == toRemove {
						indexOf = i
						break
					}
				}
				if indexOf != -1 {
					lastIndex := len(t.intArray) - 1
					t.intArray[indexOf] = t.intArray[lastIndex]
					t.intArray = t.intArray[:lastIndex]
				}
			}
		}
	}
}
func (t *testModel) Operation(o *testModelOperation) *testModelDelta {
	delta := new(testModelDelta)
	if o.NewInt != nil {
		t.int = *o.NewInt
		delta.int = &t.int
	}
	if o.NewIntPointer != nil {
		t.intPointer = o.NewIntPointer
		delta.intPointer = t.intPointer
	}
	if o.NewIntArray != nil {
		t.intArray = o.NewIntArray
		delta.intArray = t.intArray
	}
	if o.AdditionalIntArray != nil {
		if len(o.AdditionalIntArray) != 0 {
			if t.intArray == nil {
				t.intArray = make([]int, 0)
			}
			t.intArray = append(t.intArray, o.AdditionalIntArray...)
			delta.intArray = t.intArray
		}
	}
	if o.ToRemoveIntArray != nil {
		if t.intArray != nil {
			removedAny := false
			for _, toRemove := range o.ToRemoveIntArray {
				indexOf := -1
				for i, elm := range t.intArray {
					if elm == toRemove {
						indexOf = i
						break
					}
				}
				if indexOf != -1 {
					lastIndex := len(t.intArray) - 1
					t.intArray[indexOf] = t.intArray[lastIndex]
					t.intArray = t.intArray[:lastIndex]
					removedAny = true
				}
			}
			if removedAny {
				delta.intArray = t.intArray
			}
		}
	}
	return delta
}
