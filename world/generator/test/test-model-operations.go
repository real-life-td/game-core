package test

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Code generated by tools/operation-generator.go DO NOT EDIT
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

type testModelInitOperationStruct struct {
	intSet                   *int
	intPointerSet            *int
	intArraySet              []int
	intArrayAdd              []int
	intArrayRemove           []int
	intMapIntPutKey          *int
	intMapIntPutValue        *int
	intMapIntPutMultiple     map[int]int
	intMapIntDelete          []int
	intPointerMapPutKey      *int
	intPointerMapPutValue    *int
	intPointerMapPutMultiple map[*int]*int
	intPointerMapDelete      []*int
}
type testModelOperationStruct struct {
	intSet                   *int
	intPointerSet            *int
	intArraySet              []int
	intArrayAdd              []int
	intArrayRemove           []int
	intMapIntPutKey          *int
	intMapIntPutValue        *int
	intMapIntPutMultiple     map[int]int
	intMapIntDelete          []int
	intPointerMapPutKey      *int
	intPointerMapPutValue    *int
	intPointerMapPutMultiple map[*int]*int
	intPointerMapDelete      []*int
}
type testModelDelta struct {
	IntNew                 *int
	IntPointerNew          *int
	IntArrayNew            []int
	IntArrayRemovedIndices []int
	IntArrayAdded          []int
	_IntArrayArrayLength   *int
	IntMapIntDeleted       []int
	IntMapIntAdded         map[int]int
	IntPointerMapDeleted   []*int
	IntPointerMapAdded     map[*int]*int
}

func (c *testModelDelta) Merge(n *testModelDelta) {
	if n.IntNew != nil {
		c.IntNew = n.IntNew
	}
	if n.IntPointerNew != nil {
		c.IntPointerNew = n.IntPointerNew
	}
	if n.IntArrayNew != nil {
		c.IntArrayNew = n.IntArrayNew
	}
	if c.IntArrayAdded == nil {
		if c.IntArrayRemovedIndices == nil {
			if n.IntArrayAdded == nil {
				if !(n.IntArrayRemovedIndices == nil) {
					c.IntArrayRemovedIndices = n.IntArrayRemovedIndices
				}
			} else {
				if n.IntArrayRemovedIndices == nil {
					c.IntArrayAdded = n.IntArrayAdded
				} else {
					c.IntArrayAdded = n.IntArrayAdded
					c.IntArrayRemovedIndices = n.IntArrayRemovedIndices
				}
			}
		} else {
			if n.IntArrayAdded == nil {
				if !(n.IntArrayRemovedIndices == nil) {
					c.IntArrayRemovedIndices = append(c.IntArrayRemovedIndices, n.IntArrayRemovedIndices...)
				}
			} else {
				if n.IntArrayRemovedIndices == nil {
					c.IntArrayAdded = n.IntArrayAdded
				} else {
					c.IntArrayAdded = make([]int, 0)
					for _, toRemove := range n.IntArrayRemovedIndices {
						*c._IntArrayArrayLength--
						c.IntArrayRemovedIndices = append(c.IntArrayRemovedIndices, toRemove)
					}
					c.IntArrayAdded = append(c.IntArrayAdded, n.IntArrayAdded...)
				}
			}
		}
	} else {
		if c.IntArrayRemovedIndices == nil {
			if n.IntArrayAdded == nil {
				if !(n.IntArrayRemovedIndices == nil) {
					skips := make([]int, 0)
					for _, toRemove := range n.IntArrayRemovedIndices {
						if toRemove >= *c._IntArrayArrayLength {
							toSkip := toRemove - *c._IntArrayArrayLength
							skips = append(skips, toSkip)
						} else {
							*c._IntArrayArrayLength--
							c.IntArrayRemovedIndices = append(c.IntArrayRemovedIndices, toRemove)
						}
					}
					for _, toSkip := range skips {
						c.IntArrayAdded = append(c.IntArrayAdded[:toSkip], c.IntArrayAdded[toSkip+1:]...)
					}
				}
			} else {
				if n.IntArrayRemovedIndices == nil {
					c.IntArrayAdded = append(c.IntArrayAdded, n.IntArrayAdded...)
				} else {
					c.IntArrayRemovedIndices = make([]int, 0)
					skips := make([]int, 0)
					for _, toRemove := range n.IntArrayRemovedIndices {
						if toRemove >= *c._IntArrayArrayLength {
							toSkip := toRemove - *c._IntArrayArrayLength
							skips = append(skips, toSkip)
						} else {
							*c._IntArrayArrayLength--
							c.IntArrayRemovedIndices = append(c.IntArrayRemovedIndices, toRemove)
						}
					}
					for _, toSkip := range skips {
						c.IntArrayAdded = append(c.IntArrayAdded[:toSkip], c.IntArrayAdded[toSkip+1:]...)
					}
					c.IntArrayAdded = append(c.IntArrayAdded, n.IntArrayAdded...)
				}
			}
		} else {
			if n.IntArrayAdded == nil {
				if !(n.IntArrayRemovedIndices == nil) {
					skips := make([]int, 0)
					for _, toRemove := range n.IntArrayRemovedIndices {
						if toRemove >= *c._IntArrayArrayLength {
							toSkip := toRemove - *c._IntArrayArrayLength
							skips = append(skips, toSkip)
						} else {
							*c._IntArrayArrayLength--
							c.IntArrayRemovedIndices = append(c.IntArrayRemovedIndices, toRemove)
						}
					}
					for _, toSkip := range skips {
						c.IntArrayAdded = append(c.IntArrayAdded[:toSkip], c.IntArrayAdded[toSkip+1:]...)
					}
				}
			} else {
				if n.IntArrayRemovedIndices == nil {
					c.IntArrayAdded = append(c.IntArrayAdded, n.IntArrayAdded...)
				} else {
					skips := make([]int, 0)
					for _, toRemove := range n.IntArrayRemovedIndices {
						if toRemove >= *c._IntArrayArrayLength {
							toSkip := toRemove - *c._IntArrayArrayLength
							skips = append(skips, toSkip)
						} else {
							*c._IntArrayArrayLength--
							c.IntArrayRemovedIndices = append(c.IntArrayRemovedIndices, toRemove)
						}
					}
					for _, toSkip := range skips {
						c.IntArrayAdded = append(c.IntArrayAdded[:toSkip], c.IntArrayAdded[toSkip+1:]...)
					}
					c.IntArrayAdded = append(c.IntArrayAdded, n.IntArrayAdded...)
				}
			}
		}
	}
	if c.IntMapIntAdded == nil {
		if c.IntMapIntDeleted == nil {
			if n.IntMapIntAdded == nil {
				if !(n.IntMapIntDeleted == nil) {
					c.IntMapIntDeleted = n.IntMapIntDeleted
				}
			} else {
				if n.IntMapIntDeleted == nil {
					c.IntMapIntAdded = n.IntMapIntAdded
				} else {
					c.IntMapIntAdded = n.IntMapIntAdded
					c.IntMapIntDeleted = n.IntMapIntDeleted
				}
			}
		} else {
			if n.IntMapIntAdded == nil {
				if !(n.IntMapIntDeleted == nil) {
					c.IntMapIntDeleted = append(c.IntMapIntDeleted, n.IntMapIntDeleted...)
				}
			} else {
				if n.IntMapIntDeleted == nil {
					c.IntMapIntAdded = n.IntMapIntAdded
				} else {
					c.IntMapIntDeleted = append(c.IntMapIntDeleted, n.IntMapIntDeleted...)
					c.IntMapIntAdded = n.IntMapIntAdded
				}
			}
		}
	} else {
		if c.IntMapIntDeleted == nil {
			if n.IntMapIntAdded == nil {
				if !(n.IntMapIntDeleted == nil) {
					c.IntMapIntDeleted = n.IntMapIntDeleted
					for _, toRemove := range n.IntMapIntDeleted {
						delete(c.IntMapIntAdded, toRemove)
					}
				}
			} else {
				if n.IntMapIntDeleted == nil {
					for key, value := range n.IntMapIntAdded {
						c.IntMapIntAdded[key] = value
					}
				} else {
					for _, toRemove := range n.IntMapIntDeleted {
						delete(c.IntMapIntAdded, toRemove)
					}
					c.IntMapIntDeleted = n.IntMapIntDeleted
					for key, value := range n.IntMapIntAdded {
						c.IntMapIntAdded[key] = value
					}
				}
			}
		} else {
			if n.IntMapIntAdded == nil {
				if !(n.IntMapIntDeleted == nil) {
					for _, toRemove := range n.IntMapIntDeleted {
						delete(c.IntMapIntAdded, toRemove)
						c.IntMapIntDeleted = append(c.IntMapIntDeleted, toRemove)
					}
				}
			} else {
				if n.IntMapIntDeleted == nil {
					for key, value := range n.IntMapIntAdded {
						c.IntMapIntAdded[key] = value
					}
				} else {
					for _, toRemove := range n.IntMapIntDeleted {
						delete(c.IntMapIntAdded, toRemove)
						c.IntMapIntDeleted = append(c.IntMapIntDeleted, toRemove)
					}
					for key, value := range n.IntMapIntAdded {
						c.IntMapIntAdded[key] = value
					}
				}
			}
		}
	}
	if c.IntPointerMapAdded == nil {
		if c.IntPointerMapDeleted == nil {
			if n.IntPointerMapAdded == nil {
				if !(n.IntPointerMapDeleted == nil) {
					c.IntPointerMapDeleted = n.IntPointerMapDeleted
				}
			} else {
				if n.IntPointerMapDeleted == nil {
					c.IntPointerMapAdded = n.IntPointerMapAdded
				} else {
					c.IntPointerMapAdded = n.IntPointerMapAdded
					c.IntPointerMapDeleted = n.IntPointerMapDeleted
				}
			}
		} else {
			if n.IntPointerMapAdded == nil {
				if !(n.IntPointerMapDeleted == nil) {
					c.IntPointerMapDeleted = append(c.IntPointerMapDeleted, n.IntPointerMapDeleted...)
				}
			} else {
				if n.IntPointerMapDeleted == nil {
					c.IntPointerMapAdded = n.IntPointerMapAdded
				} else {
					c.IntPointerMapDeleted = append(c.IntPointerMapDeleted, n.IntPointerMapDeleted...)
					c.IntPointerMapAdded = n.IntPointerMapAdded
				}
			}
		}
	} else {
		if c.IntPointerMapDeleted == nil {
			if n.IntPointerMapAdded == nil {
				if !(n.IntPointerMapDeleted == nil) {
					c.IntPointerMapDeleted = n.IntPointerMapDeleted
					for _, toRemove := range n.IntPointerMapDeleted {
						delete(c.IntPointerMapAdded, toRemove)
					}
				}
			} else {
				if n.IntPointerMapDeleted == nil {
					for key, value := range n.IntPointerMapAdded {
						c.IntPointerMapAdded[key] = value
					}
				} else {
					for _, toRemove := range n.IntPointerMapDeleted {
						delete(c.IntPointerMapAdded, toRemove)
					}
					c.IntPointerMapDeleted = n.IntPointerMapDeleted
					for key, value := range n.IntPointerMapAdded {
						c.IntPointerMapAdded[key] = value
					}
				}
			}
		} else {
			if n.IntPointerMapAdded == nil {
				if !(n.IntPointerMapDeleted == nil) {
					for _, toRemove := range n.IntPointerMapDeleted {
						delete(c.IntPointerMapAdded, toRemove)
						c.IntPointerMapDeleted = append(c.IntPointerMapDeleted, toRemove)
					}
				}
			} else {
				if n.IntPointerMapDeleted == nil {
					for key, value := range n.IntPointerMapAdded {
						c.IntPointerMapAdded[key] = value
					}
				} else {
					for _, toRemove := range n.IntPointerMapDeleted {
						delete(c.IntPointerMapAdded, toRemove)
						c.IntPointerMapDeleted = append(c.IntPointerMapDeleted, toRemove)
					}
					for key, value := range n.IntPointerMapAdded {
						c.IntPointerMapAdded[key] = value
					}
				}
			}
		}
	}
}
func (t *testModel) InitOperation(o *testModelInitOperationStruct) {
	if o.intSet != nil {
		t.int = *o.intSet
	}
	if o.intPointerSet != nil {
		t.intPointer = o.intPointerSet
	}
	if o.intArraySet != nil {
		t.intArray = o.intArraySet
	}
	if o.intArrayRemove != nil {
		if t.intArray != nil {
			for _, toRemove := range o.intArrayRemove {
				indexOf := -1
				for i, elm := range t.intArray {
					if elm == toRemove {
						indexOf = i
						break
					}
				}
				if indexOf != -1 {
					t.intArray = append(t.intArray[:indexOf], t.intArray[indexOf+1:]...)
				}
			}
		}
	}
	if o.intArrayAdd != nil {
		if t.intArray == nil {
			t.intArray = make([]int, 0)
		}
		t.intArray = append(t.intArray, o.intArrayAdd...)
	}
	if o.intMapIntDelete != nil {
		for _, toDelete := range o.intMapIntDelete {
			delete(t.intMapInt, toDelete)
		}
	}
	if o.intPointerMapDelete != nil {
		for _, toDelete := range o.intPointerMapDelete {
			delete(t.intPointerMap, toDelete)
		}
	}
	if o.intMapIntPutKey != nil {
		t.intMapInt[*o.intMapIntPutKey] = *o.intMapIntPutValue
	}
	if o.intPointerMapPutKey != nil {
		t.intPointerMap[o.intPointerMapPutKey] = o.intPointerMapPutValue
	}
	if o.intMapIntPutMultiple != nil {
		for key, value := range o.intMapIntPutMultiple {
			t.intMapInt[key] = value
		}
	}
	if o.intPointerMapPutMultiple != nil {
		for key, value := range o.intPointerMapPutMultiple {
			t.intPointerMap[key] = value
		}
	}
}
func testModelInitOperation() *testModelInitOperationStruct {
	return &testModelInitOperationStruct{}
}

type testModelInitOperationStructInt testModelInitOperationStruct

func (op *testModelInitOperationStruct) Int() *testModelInitOperationStructInt {
	return (*testModelInitOperationStructInt)(op)
}
func (op *testModelInitOperationStructInt) Set(new int) *testModelInitOperationStruct {
	op.intSet = &new
	return (*testModelInitOperationStruct)(op)
}

type testModelInitOperationStructIntPointer testModelInitOperationStruct

func (op *testModelInitOperationStruct) IntPointer() *testModelInitOperationStructIntPointer {
	return (*testModelInitOperationStructIntPointer)(op)
}
func (op *testModelInitOperationStructIntPointer) Set(new *int) *testModelInitOperationStruct {
	op.intPointerSet = new
	return (*testModelInitOperationStruct)(op)
}

type testModelInitOperationStructIntArray testModelInitOperationStruct

func (op *testModelInitOperationStruct) IntArray() *testModelInitOperationStructIntArray {
	return (*testModelInitOperationStructIntArray)(op)
}
func (op *testModelInitOperationStructIntArray) Set(new []int) *testModelInitOperationStruct {
	op.intArraySet = new
	return (*testModelInitOperationStruct)(op)
}
func (op *testModelInitOperationStructIntArray) Remove(toRemove []int) *testModelInitOperationStruct {
	op.intArrayRemove = toRemove
	return (*testModelInitOperationStruct)(op)
}
func (op *testModelInitOperationStructIntArray) Add(toAdd []int) *testModelInitOperationStruct {
	op.intArrayAdd = toAdd
	return (*testModelInitOperationStruct)(op)
}

type testModelInitOperationStructIntMapInt testModelInitOperationStruct

func (op *testModelInitOperationStruct) IntMapInt() *testModelInitOperationStructIntMapInt {
	return (*testModelInitOperationStructIntMapInt)(op)
}
func (op *testModelInitOperationStructIntMapInt) Delete(toDelete []int) *testModelInitOperationStruct {
	op.intMapIntDelete = toDelete
	return (*testModelInitOperationStruct)(op)
}
func (op *testModelInitOperationStructIntMapInt) Put(key int, value int) *testModelInitOperationStruct {
	op.intMapIntPutKey = &key
	op.intMapIntPutValue = &value
	return (*testModelInitOperationStruct)(op)
}
func (op *testModelInitOperationStructIntMapInt) PutMultiple(toPut map[int]int) *testModelInitOperationStruct {
	op.intMapIntPutMultiple = toPut
	return (*testModelInitOperationStruct)(op)
}

type testModelInitOperationStructIntPointerMap testModelInitOperationStruct

func (op *testModelInitOperationStruct) IntPointerMap() *testModelInitOperationStructIntPointerMap {
	return (*testModelInitOperationStructIntPointerMap)(op)
}
func (op *testModelInitOperationStructIntPointerMap) Delete(toDelete []*int) *testModelInitOperationStruct {
	op.intPointerMapDelete = toDelete
	return (*testModelInitOperationStruct)(op)
}
func (op *testModelInitOperationStructIntPointerMap) Put(key *int, value *int) *testModelInitOperationStruct {
	op.intPointerMapPutKey = key
	op.intPointerMapPutValue = value
	return (*testModelInitOperationStruct)(op)
}
func (op *testModelInitOperationStructIntPointerMap) PutMultiple(toPut map[*int]*int) *testModelInitOperationStruct {
	op.intPointerMapPutMultiple = toPut
	return (*testModelInitOperationStruct)(op)
}
func (t *testModel) Operation(o *testModelOperationStruct) *testModelDelta {
	delta := new(testModelDelta)
	if o.intSet != nil {
		t.int = *o.intSet
		valueCopy := t.int
		delta.IntNew = &valueCopy
	}
	if o.intPointerSet != nil {
		t.intPointer = o.intPointerSet
		delta.IntPointerNew = o.intPointerSet
	}
	if o.intArraySet != nil {
		t.intArray = o.intArraySet
		delta.IntArrayNew = o.intArraySet
	}
	if o.intArrayRemove != nil {
		if t.intArray != nil {
			for _, toRemove := range o.intArrayRemove {
				indexOf := -1
				for i, elm := range t.intArray {
					if elm == toRemove {
						indexOf = i
						break
					}
				}
				if indexOf != -1 {
					t.intArray = append(t.intArray[:indexOf], t.intArray[indexOf+1:]...)
					if delta.IntArrayRemovedIndices == nil {
						delta.IntArrayRemovedIndices = make([]int, 0)
					}
					delta.IntArrayRemovedIndices = append(delta.IntArrayRemovedIndices, indexOf)
				}
			}
		}
		if delta._IntArrayArrayLength == nil {
			length := len(t.intArray)
			delta._IntArrayArrayLength = &length
		}
	}
	if o.intArrayAdd != nil {
		if delta._IntArrayArrayLength == nil {
			length := len(t.intArray)
			delta._IntArrayArrayLength = &length
		}
		if len(o.intArrayAdd) != 0 {
			if t.intArray == nil {
				t.intArray = make([]int, 0)
			}
			t.intArray = append(t.intArray, o.intArrayAdd...)
			if delta.IntArrayAdded == nil {
				delta.IntArrayAdded = make([]int, 0)
			}
			delta.IntArrayAdded = append(delta.IntArrayAdded, o.intArrayAdd...)
		}
	}
	if o.intMapIntDelete != nil {
		for _, toDelete := range o.intMapIntDelete {
			delete(t.intMapInt, toDelete)
			if delta.IntMapIntDeleted == nil {
				delta.IntMapIntDeleted = make([]int, 0)
			}
			delta.IntMapIntDeleted = append(delta.IntMapIntDeleted, toDelete)
		}
	}
	if o.intPointerMapDelete != nil {
		for _, toDelete := range o.intPointerMapDelete {
			delete(t.intPointerMap, toDelete)
			if delta.IntPointerMapDeleted == nil {
				delta.IntPointerMapDeleted = make([]*int, 0)
			}
			delta.IntPointerMapDeleted = append(delta.IntPointerMapDeleted, toDelete)
		}
	}
	if o.intMapIntPutKey != nil {
		t.intMapInt[*o.intMapIntPutKey] = *o.intMapIntPutValue
		if delta.IntMapIntAdded == nil {
			delta.IntMapIntAdded = make(map[int]int)
		}
		delta.IntMapIntAdded[*o.intMapIntPutKey] = *o.intMapIntPutValue
	}
	if o.intPointerMapPutKey != nil {
		t.intPointerMap[o.intPointerMapPutKey] = o.intPointerMapPutValue
		if delta.IntPointerMapAdded == nil {
			delta.IntPointerMapAdded = make(map[*int]*int)
		}
		delta.IntPointerMapAdded[o.intPointerMapPutKey] = o.intPointerMapPutValue
	}
	if o.intMapIntPutMultiple != nil {
		for key, value := range o.intMapIntPutMultiple {
			t.intMapInt[key] = value
			if delta.IntMapIntAdded == nil {
				delta.IntMapIntAdded = make(map[int]int)
			}
			delta.IntMapIntAdded[key] = value
		}
	}
	if o.intPointerMapPutMultiple != nil {
		for key, value := range o.intPointerMapPutMultiple {
			t.intPointerMap[key] = value
			if delta.IntPointerMapAdded == nil {
				delta.IntPointerMapAdded = make(map[*int]*int)
			}
			delta.IntPointerMapAdded[key] = value
		}
	}
	return delta
}
func testModelOperation() *testModelOperationStruct {
	return &testModelOperationStruct{}
}

type testModelOperationStructInt testModelOperationStruct

func (op *testModelOperationStruct) Int() *testModelOperationStructInt {
	return (*testModelOperationStructInt)(op)
}
func (op *testModelOperationStructInt) Set(new int) *testModelOperationStruct {
	op.intSet = &new
	return (*testModelOperationStruct)(op)
}

type testModelOperationStructIntPointer testModelOperationStruct

func (op *testModelOperationStruct) IntPointer() *testModelOperationStructIntPointer {
	return (*testModelOperationStructIntPointer)(op)
}
func (op *testModelOperationStructIntPointer) Set(new *int) *testModelOperationStruct {
	op.intPointerSet = new
	return (*testModelOperationStruct)(op)
}

type testModelOperationStructIntArray testModelOperationStruct

func (op *testModelOperationStruct) IntArray() *testModelOperationStructIntArray {
	return (*testModelOperationStructIntArray)(op)
}
func (op *testModelOperationStructIntArray) Set(new []int) *testModelOperationStruct {
	op.intArraySet = new
	return (*testModelOperationStruct)(op)
}
func (op *testModelOperationStructIntArray) Remove(toRemove []int) *testModelOperationStruct {
	op.intArrayRemove = toRemove
	return (*testModelOperationStruct)(op)
}
func (op *testModelOperationStructIntArray) Add(toAdd []int) *testModelOperationStruct {
	op.intArrayAdd = toAdd
	return (*testModelOperationStruct)(op)
}

type testModelOperationStructIntMapInt testModelOperationStruct

func (op *testModelOperationStruct) IntMapInt() *testModelOperationStructIntMapInt {
	return (*testModelOperationStructIntMapInt)(op)
}
func (op *testModelOperationStructIntMapInt) Delete(toDelete []int) *testModelOperationStruct {
	op.intMapIntDelete = toDelete
	return (*testModelOperationStruct)(op)
}
func (op *testModelOperationStructIntMapInt) Put(key int, value int) *testModelOperationStruct {
	op.intMapIntPutKey = &key
	op.intMapIntPutValue = &value
	return (*testModelOperationStruct)(op)
}
func (op *testModelOperationStructIntMapInt) PutMultiple(toPut map[int]int) *testModelOperationStruct {
	op.intMapIntPutMultiple = toPut
	return (*testModelOperationStruct)(op)
}

type testModelOperationStructIntPointerMap testModelOperationStruct

func (op *testModelOperationStruct) IntPointerMap() *testModelOperationStructIntPointerMap {
	return (*testModelOperationStructIntPointerMap)(op)
}
func (op *testModelOperationStructIntPointerMap) Delete(toDelete []*int) *testModelOperationStruct {
	op.intPointerMapDelete = toDelete
	return (*testModelOperationStruct)(op)
}
func (op *testModelOperationStructIntPointerMap) Put(key *int, value *int) *testModelOperationStruct {
	op.intPointerMapPutKey = key
	op.intPointerMapPutValue = value
	return (*testModelOperationStruct)(op)
}
func (op *testModelOperationStructIntPointerMap) PutMultiple(toPut map[*int]*int) *testModelOperationStruct {
	op.intPointerMapPutMultiple = toPut
	return (*testModelOperationStruct)(op)
}
